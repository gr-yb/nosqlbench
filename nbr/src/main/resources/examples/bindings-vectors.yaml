scenarios:
 default:
  vectors: run driver=stdout cycles=10 threads=1 format=readout

bindings:

    # create a simple 2-d vector from a step function over the unit interval
    # of 10 steps (the maximum number of characters per digit)
    v2d: DoubleVectors('0-2*2')
    # Combinations('a-z') [0]['a','b','c'....'z']
    # Combinations('a-z;A-Z')
    # [0]['a','b',...] (len 26)
    # [1]['A','B',...] (len 26)
    # 'aA', 'aB', 'aC'
    # Combinations('a-z*1000')
    # 26^1000
    # 2^63
    #
    # [0]['a','b',...] (len 26)
    # [1]['a','b',...] (len 26)
    # ...
    # [998]['a','b',...] (len 26)
    # [999]['a','b',...] (len 26)
    # DoubleVectors('0-9') [0.0], [0.1], [0.2], ... [0.9]
    # DoubleVectors('0-9*3')[234] [0.0,0.0,0.0], [0.0,0.0,0.1], ....
    # doubleVectorsFunction(999) -> [0.9,0.9,0.9]
    # doubleVectorsLabelFunction(999) -> "999"
    # "999" -> [ ... ]
    # 999L -> "999"
    # 999L -> [ .. ]





    # use Stringify() to visualize the value of numeric array types
    v2d_str: DoubleVectors('0-2*2'); Stringify()

    # normalize!
    v2dn: DoubleVectors('0-2*2'); NormalizeDoubleVector();

    # normalize and stringify
    v2dn_str: DoubleVectors('0-2*2'); NormalizeDoubleVector(); Stringify();

    # create a double vector based on 10 values per digit, by 10 digits.
    # this determines that the step function should be 0.1 per step, wrapping,
    # then maps this to a combinitoric model based on charset cardinality
    v1d: DoubleVectors('0-9*10');

    v1dn: DoubleVectors('0-9*10'); NormalizeDoubleVector();

    v1d_str: DoubleVectors('0-9*10'); Stringify();
    v1dn_str: DoubleVectors('0-9*10'); NormalizeDoubleVector(); Stringify();
    v1d_cql: DoubleVectors('0-9*10'); ToCqlVector();

    v_09_10f: FloatVectors('0-9*10');
    unit_v_f_n: FloatVectors('0-9*10'); NormalizeFloatVector();
    v_az_3: DoubleVectors('a-z*3');
    unit_v_d_n: DoubleVectors('a-z*5'); NormalizeDoubleVector();



